# Complexity

## 복잡도 (Complexity)

### 1. 시간복잡도 (Time Complexity)

점근적 실행 시간(asymptotic runtime), 또는 big-O 시간에 대한 개념

#### 1.1 정의 : 알고리즘의 실행비용을 나타내는 지표

* 알고리즘 실행 속도는 컴퓨터의 처리속도, 사용된 언어 종류, 프로그래밍 언어를 컴퓨터가 실행할 수 있는 코드로 바꾸는 컴파일러의 속도에 달려있다.

#### 1.2 알고리즘의 점근적 표기법

* 상수 계수와 중요하지 않은 항목을 제거한 방법
* 세 가지 형태를 갖추고 있다.

##### 1.2.1 Big-O

* O notation definition : 선형식
  * 시간의 상한(supremum), 최소 상계(least upper bound)을 나타낸다.
  * 배열의 모든 값을 출력하는 알고리즘은 O(N)으로 표현할 수 있지만 이외에도 N보다 큰 big-O 시간으로 표현할 수도 있다. 예를 들어 O(N ** 2), O(N ** 3), O(2 ^n). 알고리즘의 수행 시간은 적어도 이들 중 하나보다 빠르기만 하면 된다. 따라서 big-O 시간은 알고리즘 수행 시간의 상한이 되고, 이는 '작거나 같은' 부등호와도 비슷한 관계가 있다. 
  * Bob의 나이가 X라면 X <=130이라고 말할 수 있지만, X <= 1000 모두 참인 표현법이다. 마찬가지로 배열의 모든 값을 출력하는 알고리즘은 O(N)이라고 표현할 수 있을 뿐만 아니라 O(N^3) 혹은 O(N) 보다 큰 어떤 수행 시간으로도 표현 가능하다.
* O(1) : 상수 (비유: 파일의 크기가 증가한다고 해서 파일을 전송하는 데 걸리는 시간이 늘어나지 않는다.)

```

for large enough N:
    if k exists such that
        f(n) < kn ** 2
        f(n)의 O(n**2)

```

##### 1.2.2 Big-Omega

* Ω notation definition :
  * 등가 개념 혹은 하한(infimum), 최대 하계(greatest lower bound)을 나타낸다.
  * 배열의 모든 값을 출력하는 알고리즘은 Ω(N) 뿐만 아니라 Ω(logN) 혹은 Ω(1)로도 표현할 수 있다. 결국 해당 알고리즘은 Ω 수행 시간보다 빠를 수 없게 된다.

```

for large enough N:
    if k exists such that
        kn ** 2 < f(n)
            f의 시간복잡도는 Ω(n ** 2)

```

##### 1.2.3 Big-Theta

* Θ notation definition
  * 특정 시간이 Θ(n)이라고 하는 것은 n 이 충분히 크다면, 실행 시간이 어떤 상수 k1와 k2에 대해서 최소 k1 * n이며 최대 k2 * n이 된다는 뜻이다.
  * 실행 시간에 대해 점근적(큰 값의 n에 대해서만 적용. 위, 아래로 상수값 내에서 실행시간을 좁힐 수 있다.)으로 근접한 한계값이 있다고 표현한다.

  * Θ는 O와 Ω 둘 다 의미한다. 즉, 어떤 알고리즘의 수행시간이 O(N)이면서 Ω(N)이라면, 이 알고리즘의 수행 시간을 Θ(N)으로 표현한다. 
  * 컴퓨터과학에서는 Θ와 O를 하나로 합쳐 표현하려는 것 같다.

```

for large enough N:
    if a, b exists such that
        an ** 2 < f(n) < bn ** 2
        f의 시간 복잡도는 Θ(n ** 2)

```

#### 1.3 최고차항이란

x를 극한으로 보낼 때, 함숫값의 차이로 결국에 추월되는 식의 일반화 조건. 상한과 하한을 설명할 수 있다.

* 일반화한 식1 : 1 < log x < x
* 일반화한 식2 : x < x ^ 2 < x ^ 3 < … <  x ^ n < e ^ x

사실 알고리즘을 엄밀하게 계산할 수 없다. O(x) 를 쓰는 이유는 …

참고 (인터뷰에 나오지 않습니다.)
오메가 : 하한을 알려줄 때 사용한다. (‘적어도 이정도의 시간이 걸린다.’의 의미)
=> 모든 알고리즘의 시간복잡도는 Ω(1) 로 나온다. 그러나 그게 무슨 의미가,,
세타 : 정확하게 계산할 수 있을 때 사용한다.
=> ax ** 2 <= f(x) <= bx ** 2

### 2. 공간 복잡도 (Space Complexity)

#### 2.1 정의: 알고리즘을 실행하는 데 필요한 작업 기억 영역의 양

* 메모리를 얼a마나 쓸 것인지 표시합니다. 그러나 시간복잡도만큼 중요하지 않습니다.

### 3. Amortized Analysis

* 사용 이유 : 알고리즘을 분석할 때에 각각의 연산마다 최악의 경우를 따져보는 것은 굉장히 힘든 문제가 있어, 이를 해결하기 위한 방법론.
* 알고리즘이 어느 정도 스케일로 느린지 이해하기 위한 수단으로서 특이한 경우가 있을 때를 가정한다.
* 모범답변 : amortized의 경우에는 ~ 이고, 최악의 경우에는 ~ 입니다.

* 활용 :
  * 동적배열(java의 array list, python의 list) 에서 push를 하다가, 빈칸이 모자랄 때 빈칸을 더 만들어내는 경우
  * 벡터에 데이터를 삽입하는 것에 대한 시간 복잡도를 물어보는 경우